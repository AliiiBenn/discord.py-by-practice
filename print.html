<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Discord.py Exercices</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var html = document.querySelector('html');
            var sidebar = null;
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="chapter_1/events.html"><strong aria-hidden="true">2.</strong> Chapter 1 - Events</a></li><li class="chapter-item expanded "><a href="chapter_2/commands.html"><strong aria-hidden="true">3.</strong> Chapter 2 - Commands</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_2/without_arguments.html"><strong aria-hidden="true">3.1.</strong> without arguments</a></li><li class="chapter-item expanded "><a href="chapter_2/unique_argument.html"><strong aria-hidden="true">3.2.</strong> unique argument</a></li><li class="chapter-item expanded "><a href="chapter_2/multiple_arguments.html"><strong aria-hidden="true">3.3.</strong> multiple arguments</a></li><li class="chapter-item expanded "><a href="chapter_2/string_arguments.html"><strong aria-hidden="true">3.4.</strong> string arguments</a></li><li class="chapter-item expanded "><a href="chapter_2/commands_errors.html"><strong aria-hidden="true">3.5.</strong> commands errors</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_3/basic_converters.html"><strong aria-hidden="true">4.</strong> Chapter 3 - Bacic Converters</a></li><li class="chapter-item expanded "><a href="chapter_4/cogs.html"><strong aria-hidden="true">5.</strong> Chapter 4 - Cogs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_4/add_commands_to_a_cog.html"><strong aria-hidden="true">5.1.</strong> add commands to a cog</a></li><li class="chapter-item expanded "><a href="chapter_4/add_events_to_a_cog.html"><strong aria-hidden="true">5.2.</strong> add events to a cog</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_5/embeds.html"><strong aria-hidden="true">6.</strong> Chapter 5 - Embeds</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_5/create_an_embed.html"><strong aria-hidden="true">6.1.</strong> create an embed</a></li><li class="chapter-item expanded "><a href="chapter_5/customize_an_embed.html"><strong aria-hidden="true">6.2.</strong> customize an embed</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_6/slash_commands.html"><strong aria-hidden="true">7.</strong> Chapter 6 - Slash Commands</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_6/create_a_slash_command.html"><strong aria-hidden="true">7.1.</strong> create a slash command</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_7/hybrid_commands.html"><strong aria-hidden="true">8.</strong> Chapter 7 - Hybrid Commands</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_7/create_a_hybrid_command.html"><strong aria-hidden="true">8.1.</strong> create a hybrid command</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_8/converters.html"><strong aria-hidden="true">9.</strong> Chapter 8 - Converters</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_8/functions_converters.html"><strong aria-hidden="true">9.1.</strong> functions converters</a></li><li class="chapter-item expanded "><a href="chapter_8/advanced_converters.html"><strong aria-hidden="true">9.2.</strong> advanced converters</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Discord.py Exercices</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Bienvenue dans ce site qui répertorie une liste d'exercices pour apprendre à utiliser la librairie discord.py. Ce site est destiné aux personnes qui ont déjà une certaine expérience en programmation et qui souhaitent apprendre à utiliser la librairie discord.py.</p>
<p>Chaque chapitre représente un concept clé de la librairie discord.py. Chaque chapitre contient une liste d'exercices qui permettent de mettre en pratique ce concept. Les exercices sont classés par difficulté et sont accompagnés d'une solution. Essayez de suivre les exercices dans l'ordre et de ne pas regarder la solution avant d'avoir essayé de résoudre l'exercice par vous-même. Si vous avez des questions, n'hésitez pas à me contacter sur discord (AliBen#7502).</p>
<p>Au cours des exercices, la façon dont vont être écrites les commandes va changer car il y aura une mise en place de ce que l'on appelle le type hint et les converters qui seront surtout vus dans les chapitre 3 et 8. </p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-1---events"><a class="header" href="#chapter-1---events">Chapter 1 - Events</a></h1>
<p>Dans discord.py, les évènements sont des méthodes qui sont appelées lorsqu'un évènement est déclenché. Par exemple, lorsqu'un message est envoyé dans un salon, la méthode <code>on_message</code> est appelée avec en paramètre le message envoyé. Pour créer un évènement, on utilise la syntaxe suivante :</p>
<pre><code class="language-python">@bot_name.event
async def event_name(*args, **kwargs):
    ...
</code></pre>
<p>Par exemple, pour créer un évènement <code>on_ready</code> qui est appelé lorsque le bot est prêt, on utilise la syntaxe suivante :</p>
<pre><code class="language-python">@bot.event
async def on_ready():
    print(&quot;Ready !&quot;)
</code></pre>
<p>Cet exemple affiche le message &quot;Ready !&quot; dans la console lorsque le bot est prêt.</p>
<hr />
<h1 id="exercices"><a class="header" href="#exercices">Exercices</a></h1>
<h3 id="exercice-1"><a class="header" href="#exercice-1">Exercice 1</a></h3>
<p>Créer un évènement <code>on_ready</code> qui affiche le message &quot;Je suis en ligne !&quot; dans la console lorsque le bot est prêt.</p>
<details>
  <summary>Solution</summary>
<pre><code class="language-python">@bot.event
async def on_ready():
    print(&quot;Je suis en ligne !&quot;)
</code></pre>
</details>
<h3 id="exercice-2"><a class="header" href="#exercice-2">Exercice 2</a></h3>
<p>Créer un évènement <code>on_message</code> qui regarde si le message a été envoyé par un bot. Si ce n'est pas le cas et que le message contient &quot;Hello&quot;, le bot répond &quot;Hello !&quot;.</p>
<details>
  <summary>Solution</summary>
<pre><code class="language-python">@bot.event
async def on_message(message):
    if not message.author.bot and message.content == &quot;Hello&quot;:
        await message.channel.send(&quot;Hello !&quot;)
</code></pre>
</details><div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-2---commands"><a class="header" href="#chapter-2---commands">Chapter 2 - Commands</a></h1>
<p>Dans discord.py, les commandes sont des méthodes qui sont appelées lorsqu'une commande est exécutée. Par exemple, lorsqu'un utilisateur exécute la commande <code>!ping</code>, la méthode <code>ping</code> est appelée. Pour créer une commande, on utilise la syntaxe suivante :</p>
<pre><code class="language-python">@bot_name.command()
async def command_name(*args, **kwargs):
    ...
</code></pre>
<p>Par exemple, pour créer une commande <code>ping</code> qui est appelée lorsque l'utilisateur exécute la commande <code>!ping</code>, on utilise la syntaxe suivante :</p>
<pre><code class="language-python">@bot.command()
async def ping(ctx):
    await ctx.send(&quot;Pong !&quot;)
</code></pre>
<p>Cet exemple envoie le message &quot;Pong !&quot; dans le salon dans lequel la commande a été exécutée.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="without-arguments"><a class="header" href="#without-arguments">without arguments</a></h1>
<p>Les commandes les plus simples sont celles qui n'ont pas d'arguments. Pour créer une commande sans arguments, il suffit de définir une fonction avec le décorateur <code>@bot.command()</code> et de définir le paramètre <code>ctx</code> de la fonction. Ce paramètre est un objet de type <code>commands.Context</code>. Cet objet est obtenu à partir du paramètre <code>ctx</code> de la fonction de la commande. Cet objet contient des informations sur la commande et sur le message qui a appelé la commande. Il est donc nécessaire de le passer en premier paramètre de la fonction de la commande.</p>
<p>Malgré cela, il est complètement possible de ne passer aucun autre argument de ce fait, une commande sans arguments aura la structure suivante :</p>
<pre><code class="language-python">@bot.command()
async def command_name(ctx : commands.Context) -&gt; None:
    ...
</code></pre>
<p>Ces commandes peuvent rester utiles dans certains grâce au contexte qui offre à lui seul une grande quantité d'informations.</p>
<hr />
<h1 id="exercices-1"><a class="header" href="#exercices-1">Exercices</a></h1>
<h3 id="exercice-1-1"><a class="header" href="#exercice-1-1">Exercice 1</a></h3>
<p>Créer une commande <code>hello</code> qui prends comme unique argument le contexte de notre commande. Cette commande doit simplement renvoyer &quot;Hello, World&quot;. Pour envoyer un message, il faut utiliser la méthode <code>send</code> obtenue à partir du contexte de la commande (<code>ctx.send</code>).</p>
<details>
  <summary>Solution</summary>
<pre><code class="language-python">@bot.command()
async def hello(ctx : commands.Context) -&gt; None:
    await ctx.send(&quot;Hello World!&quot;)
</code></pre>
</details>
<h3 id="exercice-2-1"><a class="header" href="#exercice-2-1">Exercice 2</a></h3>
<p>Compléter la commande <code>numbers</code> pour qu'elle envoie les nombres de 0 à 9 à l'aide de la méthode <code>send</code> obtenue à partir du contexte de la commande ( <code>ctx.send</code> ).</p>
<pre><code class="language-python">@bot.command()
async def numbers(ctx : commands.Context) -&gt; None:
    ...
</code></pre>
<details>
  <summary>Solution</summary>
<pre><code class="language-python">@bot.command()
async def numbers(ctx : commands.Context) -&gt; None:
    for i in range(10):
        await ctx.send(i)
</code></pre>
</details>
<h3 id="exercice-3"><a class="header" href="#exercice-3">Exercice 3</a></h3>
<p>Compléter la commande <code>ping</code> pour qu'elle renvoie la latence du bot en millisecondes à l'aide de l'attribut <code>latency</code> du bot. La latence en millisecondes est obtenue en multipliant la valeur de l'attribut <code>latency</code> par 1000. La valeur doit être arrondie à deux chiffres après la virgule.</p>
<pre><code class="language-python">@bot.command()
async def ping(ctx : commands.Context) -&gt; None:
    ...
</code></pre>
<details>
  <summary>Solution</summary>
<pre><code class="language-python">@bot.command()
async def ping(ctx : commands.Context) -&gt; None:
    await ctx.send(f&quot;Pong! {bot.latency * 1000:.2f} ms&quot;)
</code></pre>
</details>
<h3 id="exercice-4"><a class="header" href="#exercice-4">Exercice 4</a></h3>
<p>Compléter la commande <code>hello</code> pour qu'elle envoie un message privé à l'auteur de la commande avec le contenu &quot;Hello World!&quot; à l'aide de la méthode <code>send</code> obtenue à partir du contexte de la commande (<code>ctx.author.send</code>).</p>
<pre><code class="language-python">@bot.command()
async def hello(ctx : commands.Context) -&gt; None:
    ...
</code></pre>
<details>
  <summary>Solutions</summary>
<pre><code class="language-python">@bot.command()
async def hello(ctx : commands.Context) -&gt; None:
    await ctx.author.send(&quot;Hello World!&quot;)
</code></pre>
</details>
<h3 id="exercice-5"><a class="header" href="#exercice-5">Exercice 5</a></h3>
<p>Créer une commande <code>coinflip</code> qui ne prends aucun argument et qui doit renvoyer aléatoirement &quot;Heads&quot; ou &quot;Tails&quot;. La structure de la commande est la suivante :</p>
<pre><code class="language-python">@bot.command()
async def coinflip(ctx : commands.Context) -&gt; None:
    ...
</code></pre>
<details>
  <summary>Solution</summary>
<pre><code class="language-python">import random

@bot.command()
async def coinflip(ctx : commands.Context) -&gt; None:
    await ctx.send(random.choice([&quot;Heads&quot;, &quot;Tails&quot;]))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unique-argument"><a class="header" href="#unique-argument">unique argument</a></h1>
<p>Il est possible de créer des commandes qui prennent un unique argument en plus du contexte. Pour créer une commande avec un unique argument, il suffit de définir une fonction avec le décorateur <code>@bot.command()</code> et de définir le paramètre <code>ctx</code> de la fonction. Ensuite, il est possible de rajouter le paramètre de notre choix, il peut avoir le type que l'on veut (attention pour les chaînes de caractères, on verra pourquoi dans les prochains exercices).</p>
<p>Donc une commande avec un unique argument aura la structure suivante :</p>
<pre><code class="language-python">    @bot.command()
    async def command_name(ctx : commands.Context, argument : type) -&gt; None:
        ...
</code></pre>
<br>
<hr />
<h1 id="exercices-2"><a class="header" href="#exercices-2">Exercices</a></h1>
<h3 id="exercice-1-2"><a class="header" href="#exercice-1-2">Exercice 1</a></h3>
<p>On veut créer une commande qui prends un unique argument en plus du contexte qui est un entier <code>int</code> et on veut renvoyer son double à l'aide de la méthode <code>send</code> obtenue à partir du contexte de la commande (<code>ctx.send</code>). La structure de la commande est la suivante :</p>
<pre><code class="language-python">    @bot.command()
    async def double(ctx : commands.Context, number : int) -&gt; None:
        ...
</code></pre>
<details>
  <summary>Solution</summary>
<pre><code class="language-python">@bot.command()
async def double(ctx : commands.Context, number : int) -&gt; None:
    await ctx.send(number * 2)
</code></pre>
</details>
<h3 id="exercice-2-2"><a class="header" href="#exercice-2-2">Exercice 2</a></h3>
<p>Créer une commande <code>hello_member</code> qui prends en paramètre un membre et qui renvoie le message suivant : &quot;Hello {member.mention}!&quot;. Pour envoyer un message, il faut utiliser la méthode <code>send</code> obtenue à partir du contexte de la commande (<code>ctx.send</code>). Pour mentionner un membre, il faut utiliser l'attribut <code>mention</code> du membre (member.mention). Le paramètre <code>member</code> doit être de type <code>discord.Member</code>.</p>
<details>
  <summary>Solution</summary>
<pre><code class="language-python">@bot.command()
async def hello(ctx : commands.Context, member : discord.Member) -&gt; None:
    await ctx.send(f&quot;Hello {member.mention}!&quot;)
</code></pre>
</details>
<h3 id="exercice-3-1"><a class="header" href="#exercice-3-1">Exercice 3</a></h3>
<p>Créer une commands <code>send_message</code> qui prends en paramètre un channel et qui renvoie le &quot;Hello !&quot; dans le channel spécifié. Pour envoyer un message dans un channel, il faut utiliser la méthode <code>send</code> obtenue à partir du channel (channel.send). Le paramètre <code>channel</code> doit être de type <code>discord.TextChannel</code>.</p>
<details>
  <summary>Solution</summary>
<pre><code class="language-python">@bot.command()
async def hello(ctx : commands.Context, channel : discord.TextChannel) -&gt; None:
    await channel.send(&quot;Hello !&quot;)
</code></pre>
</details>
<h3 id="exercice-4-1"><a class="header" href="#exercice-4-1">Exercice 4</a></h3>
<p>Créer une commande qui prends un unique paramètre optionnel qui est un membre et qui doit renvoyer la liste des rôles de ce membre. Si le membre n'est pas spécifié, la commande doit renvoyer la liste des rôles de l'auteur de la commande. Les rôles d'un membre peuvent être obtenus à partir de l'attribut <code>roles</code> du membre (member.roles).</p>
<details>
  <summary>Solution</summary>
<pre><code class="language-python">@bot.command()
async def roles(ctx : commands.Context, member : discord.Member = None) -&gt; None:
    if member is None:
        member = ctx.author

    await ctx.send(&quot;, &quot;.join(role.name for role in member.roles))
</code></pre>
<p>ou </p>
<pre><code class="language-python">@bot.command()
async def roles(ctx : commands.Context, member : discord.Member = None) -&gt; None:
    if member is None:
        member = ctx.author

    for role in member.roles:
        await ctx.send(role.name)
</code></pre>
</details>
<h3 id="exercice-5-1"><a class="header" href="#exercice-5-1">Exercice 5</a></h3>
<p>Des fois, il nous arrive de ne plus retrouver nos membres, on aimerait pouvoir les retrouver facilement. Pour cela, on va créer une commande qui prends en paramètre un membre et qui renvoie le nombre de jours depuis la dernière connexion de ce membre. Pour obtenir la date de la dernière connexion d'un membre, il faut utiliser l'attribut <code>joined_at</code> du membre (member.joined_at). Pour obtenir la date actuelle, il faut utiliser la fonction <code>datetime.datetime.now()</code>.</p>
<p>Notre commande aura donc la structure suivante :</p>
<pre><code class="language-python">@bot.command()
async def last_connection(ctx : commands.Context, member : discord.Member) -&gt; None:
    ...
</code></pre>
<details>
  <summary>Solution</summary>
<pre><code class="language-python">@bot.command()
async def last_connection(ctx : commands.Context, member : discord.Member) -&gt; None:
    await ctx.send((datetime.datetime.now() - member.joined_at).days)
</code></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="multiple-arguments"><a class="header" href="#multiple-arguments">multiple arguments</a></h1>
<p>Commands can take multiple arguments, which can be defined by specifying multiple parameters in the command function. However, it is important to note that the first parameter should always be the context of the command, which means that it should be an object of type <code>commands.Context</code>. This object can be obtained from the <code>ctx</code> parameter of the command function, and it contains information about the command and the message that triggered the command. Therefore, it is necessary to pass it as the first parameter of the command function.</p>
<p>Furthermore, if one of the arguments is a string, it should be preceded by an asterisk. This indicates that the parameter can contain spaces. If the asterisk is not included, the parameter will only contain the first word. Finally, it is possible to add other parameters to the command before the parameter that can contain spaces, but no parameters can be placed after the parameter that can contain spaces.</p>
<p>The command structure for commands that take multiple arguments is as follows:</p>
<pre><code class="language-python">@bot.command()
async def command_name(ctx : commands.Context, argument_1, ..., argument_n) -&gt; None:
    ...
</code></pre>
<hr />
<h1 id="exercices-3"><a class="header" href="#exercices-3">Exercices</a></h1>
<h3 id="exercice-1-3"><a class="header" href="#exercice-1-3">Exercice 1</a></h3>
<p>Créer une commande <code>remove_role</code> qui prends en paramètre un membre (<code>discord.Member</code>) et un rôle (<code>discord.Role</code>), qui regarde si ce membre a le rôle spécifié et qui le supprime si c'est le cas. Pour supprimer un rôle à un membre, il faut utiliser la méthode <code>remove_roles</code> obtenue à partir du membre (member.remove_roles). Si le rôle a été enlevé, la commande doit renvoyer le message suivant : &quot;Le rôle {role.name} a été enlevé à {member.name}.&quot;. Si le rôle n'a pas été enlevé, la commande doit renvoyer le message suivant : &quot;{member.name} n'a pas le rôle {role.name}.&quot;. </p>
<details>
  <summary>Solution</summary>
<pre><code class="language-python">@bot.command()
async def remove_role(ctx : commands.Context, member : discord.Member, role : discord.Role) -&gt; None:
    if role in member.roles:
        await member.remove_roles(role)
        return await ctx.send(f&quot;Le rôle {role.name} a été enlevé à {member.name}.&quot;)
    
    return await ctx.send(f&quot;{member.name} n'a pas le rôle {role.name}.&quot;)
</code></pre>
</details>
<h3 id="exercice-2-3"><a class="header" href="#exercice-2-3">Exercice 2</a></h3>
<p>Maintenant que l'on sait enlever les rôles, il est temps d'en ajouter. Créer une commande <code>add_role</code> qui prends en paramètre un membre (<code>discord.Member</code>) et un rôle (<code>discord.Role</code>), qui regarde si ce membre a le rôle spécifié et qui l'ajoute si ce n'est pas le cas. Pour ajouter un rôle à un membre, il faut utiliser la méthode <code>add_roles</code> obtenue à partir du membre (member.add_roles). Si le rôle a été ajouté, la commande doit renvoyer le message suivant : &quot;Le rôle {role.name} a été ajouté à {member.name}.&quot;. Si le rôle n'a pas été ajouté, la commande doit renvoyer le message suivant : &quot;{member.name} a déjà le rôle {role.name}.&quot;.</p>
<details>
  <summary>Solution</summary>
<pre><code class="language-python">@bot.command()
async def add_role(ctx : commands.Context, member : discord.Member, role : discord.Role) -&gt; None:
    if role not in member.roles:
        await member.add_roles(role)
        return await ctx.send(f&quot;Le rôle {role.name} a été ajouté à {member.name}.&quot;)
    
    return await ctx.send(f&quot;{member.name} a déjà le rôle {role.name}.&quot;)
</code></pre>
</details>
<h3 id="exercice-3-2"><a class="header" href="#exercice-3-2">Exercice 3</a></h3>
<p>Créer une commands <code>slowmode</code> qui prends en paramètre un channel (<code>discord.TextChannel</code>) et un nombre de secondes (<code>int</code>), qui change le slowmode du channel spécifié en secondes. Pour changer le slowmode d'un channel, il faut utiliser la méthode <code>edit</code> obtenue à partir du channel (channel.edit). Si la valeur en seconde est inférieure à 0, la commande doit renvoyer le message suivant : &quot;Le slowmode ne peut pas être inférieur à 0.&quot;. Si la valeur en seconde est supérieure à 21600, la commande doit renvoyer le message suivant : &quot;Le slowmode ne peut pas être supérieur à 21600.&quot;. Sinon, la commande doit renvoyer le message suivant : &quot;Le slowmode du channel {channel.name} a été changé en {seconds} secondes.&quot;. </p>
<details>
  <summary>Solution</summary>
<pre><code class="language-python">@bot.command()
async def slowmode(ctx : commands.Context, channel : discord.TextChannel, seconds : int) -&gt; None:
    if seconds &lt; 0:
        return await ctx.send(&quot;Le slowmode ne peut pas être inférieur à 0.&quot;)
    
    if seconds &gt; 21600:
        return await ctx.send(&quot;Le slowmode ne peut pas être supérieur à 21600.&quot;)
    
    await channel.edit(slowmode_delay=seconds)
    return await ctx.send(f&quot;Le slowmode du channel {channel.name} a été changé en {seconds} secondes.&quot;)
</code></pre>
</details>
<h3 id="exercice-4-2"><a class="header" href="#exercice-4-2">Exercice 4</a></h3>
<p>On aimerait pouvoir changer de salon vocal sans avoir à toucher à notre souris car c'est un peu long. Pour cela, on va créer une commande qui permet de changer de salon vocal. Pour cela, on va créer une commande <code>move</code> qui prends en paramètre optionnel un salon vocal et qui déplace le membre qui a exécuté la commande dans le salon vocal spécifié. Si le paramètre n'est pas spécifié on déconnecte le membre de son salon actuel. Pour déplacer un membre dans un salon vocal, il faut utiliser la méthode <code>move_to</code> obtenue à partir du membre (member.move_to) et attention, il n'est pas possible de move un membre qui n'est pas dans un salon vocal, il faudra donc vérifier ce cas. Le paramètre <code>channel</code> doit être de type <code>discord.VoiceChannel</code>.</p>
<p>La commande doit être de la forme suivante :</p>
<pre><code class="language-python">@bot.command()
async def move(ctx : commands.Context,
               channel : Optional[discord.VoiceChannel] = None) -&gt; discord.Message:
    ...
</code></pre>
<details>
  <summary>Solution</summary>
<pre><code class="language-python">@bot.command()
async def move(ctx : commands.Context,
               channel : Optional[discord.VoiceChannel] = None) -&gt; discord.Message:
    try:
        ctx.author.move_to(channel)
    except discord.HTTPException:
        return await ctx.send(&quot;You are not in a voice channel.&quot;)

    return await ctx.send(f&quot;Moved to {channel.name}&quot;)

</code></pre>
<p>On utilise un <code>try</code>/<code>except</code> pour gérer le cas où le membre n'est pas dans un salon vocal. Si le membre n'est pas dans un salon vocal, une exception <code>discord.HTTPException</code> est levée et on renvoie un message d'erreur. Sinon on déplace le membre dans le salon vocal spécifié et on renvoie un message de confirmation.</p>
</details><div style="break-before: page; page-break-before: always;"></div><h1 id="string-arguments"><a class="header" href="#string-arguments">string arguments</a></h1>
<p>Les commandes <code>discord.py</code> peuvent prendre comme argument des chaînes de caractères à la seule condition que ces chaînes de caractères ne contiennent pas d'espaces. Si on veut que la commande puisse prendre une chaîne de caractère avec des espaces, 
il faut précéder le paramètre de la commande par un astérisque. Cela signifie que le paramètre peut contenir des espaces. Si on ne met pas cet astérisque, 
le paramètre ne contiendra que le premier mot.</p>
<p>De ce fait, 
la structure d'une commande qui prends une chaîne de caractère avec des espaces est la suivante :</p>
<pre><code class="language-python">@bot.command()
async def command_name(ctx : commands.Context, *, string : str) -&gt; None:
    ...
</code></pre>
<p>Il est bien sûr possible d'ajouter d'autres paramètres à la commande avant le paramètre qui peut contenir des espaces mais aucun paramètre ne peut être placé après le paramètre qui peut contenir des espaces.</p>
<p>Nous allons voir une liste d'exercices pour comprendre comment utiliser les chaînes de caractères avec des espaces dans les commandes.</p>
<hr />
<h1 id="exercices-4"><a class="header" href="#exercices-4">Exercices</a></h1>
<h3 id="exercice-1-4"><a class="header" href="#exercice-1-4">Exercice 1</a></h3>
<p>Créer une commande <code>repeat</code>qui prends en argument le contexte et une chaîne de caractère et qui renvoie ce message à l'aide de la méthode <code>send</code> obtenue à partir du contexte de la commande (<code>ctx.send</code>).</p>
<details>
  <summary>Solution</summary>
<pre><code class="language-python">@bot.command()
async def repeat(ctx : commands.Context, *, message : str) -&gt; None:
    await ctx.send(message)
</code></pre>
<p>On voit ici que le paramètre <code>message</code> est précédé d'un astérisque. Cela signifie que le paramètre peut contenir des espaces. Si on ne met pas cet astérisque, 
le paramètre ne contiendra que le premier mot. Ensuite, 
on peut utiliser la variable <code>message</code> comme une chaîne de caractère normale et donc envoyer le message avec <code>ctx.send(message)</code>.</p>
</details>
<h3 id="exercice-2-4"><a class="header" href="#exercice-2-4">Exercice 2</a></h3>
<p>Créer une commande <code>sum</code> qui prends en argument une chaîne de caractère qui va représenter une liste de nombres séparés par des virgules et qui va renvoyer la somme de ces nombres. Par exemple, 
si on appelle la commande avec la chaîne de caractère <code>1,  2,  3,  4,  5</code>, 
la commande doit renvoyer <code>15</code>.</p>
<details>
  <summary>Solution</summary>
<pre><code class="language-python">@bot.command()
async def sum(ctx : commands.Context, 
*, 
numbers : str) -&gt; None:
    await ctx.send(sum(int(number) for number in numbers.split(&quot;,&quot;)))
</code></pre>
</details>
<h3 id="exercice-3-3"><a class="header" href="#exercice-3-3">Exercice 3</a></h3>
<p>Créer une commande <code>eightball</code> qui prends en argument une chaîne de caractère et qui renvoie une réponse aléatoire parmi une liste de réponses. Par exemple, 
si on appelle la commande avec la chaîne de caractère <code>Est-ce que je vais réussir mon examen ?</code>, 
la commande doit renvoyer une réponse aléatoire parmi une liste de réponses.</p>
<p>La liste de réponses est la suivante :</p>
<pre><code class="language-python">responses = [
    &quot;It is certain,&quot;
    &quot;It is decidedly so,&quot;
    &quot;Without a doubt,&quot;
    &quot;Yes definitely,&quot;
    &quot;You may rely on it,&quot;
    &quot;As I see it,&quot;
    &quot;yes,&quot;
    &quot;Most likely,&quot;
    &quot;Outlook good,&quot;
    &quot;Yes,&quot;
    &quot;Signs point to yes,&quot;
    &quot;Don't count on it,&quot;
    &quot;My reply is no,&quot;
    &quot;My sources say no,&quot;
    &quot;Outlook not so good,&quot;
    &quot;Very doubtful,&quot;
    &quot;Reply hazy try again,&quot;
    &quot;Ask again later,&quot;
    &quot;Better not tell you now,&quot;
    &quot;Cannot predict now,&quot;
    &quot;Concentrate and ask again&quot;
]
</code></pre>
<p>(On peut utiliser la fonction <code>random.choice</code> pour obtenir un élément aléatoire d'une liste.)</p>
<details>
  <summary>Solution</summary>
<pre><code class="language-python">import random

@bot.command()
async def eightball(ctx : commands.Context, *, question : str) -&gt; None:
    responses = [
        &quot;It is certain,&quot;
        &quot;It is decidedly so,&quot;
        &quot;Without a doubt,&quot;
        &quot;Yes definitely,&quot;
        &quot;You may rely on it,&quot;
        &quot;As I see it,&quot;
        &quot;yes,&quot;
        &quot;Most likely,&quot;
        &quot;Outlook good,&quot;
        &quot;Yes,&quot;
        &quot;Signs point to yes,&quot;
        &quot;Don't count on it,&quot;
        &quot;My reply is no,&quot;
        &quot;My sources say no,&quot;
        &quot;Outlook not so good,&quot;
        &quot;Very doubtful,&quot;
        &quot;Reply hazy try again,&quot;
        &quot;Ask again later,&quot;
        &quot;Better not tell you now,&quot;
        &quot;Cannot predict now,&quot;
        &quot;Concentrate and ask again&quot;
    ]
    await ctx.send(f&quot;Question: {question}\nAnswer: {random.choice(responses)}&quot;)
</code></pre>
</details>
<h3 id="exercice-4-3"><a class="header" href="#exercice-4-3">Exercice 4</a></h3>
<p>Créer une commande <code>reverse</code> qui prends en argument une chaîne de caractère et qui renvoie la chaîne de caractère inversée. Par exemple, 
si on appelle la commande avec la chaîne de caractère <code>Hello</code>, 
la commande doit renvoyer <code>olleH</code>.</p>
<details>
  <summary>Solution</summary>
<pre><code class="language-python">@bot.command()
async def reverse(ctx : commands.Context, *, string : str) -&gt; None:
    await ctx.send(string[::-1])
</code></pre>
<p>ou </p>
<pre><code class="language-python">@bot.command()
async def reverse(ctx : commands.Context, *, string : str) -&gt; None:
    await ctx.send(&quot;&quot;.join(reversed(string)))
</code></pre>
<p>ou </p>
<pre><code class="language-python">@bot.command()
async def reverse(ctx : commands.Context, *, string : str) -&gt; None:
    result = []
    for letter in string:
        result.insert(0, letter)

    await ctx.send(&quot;&quot;.join(result))
</code></pre>
</details>
<h3 id="exercice-5-2"><a class="header" href="#exercice-5-2">Exercice 5</a></h3>
<p>On aime les palindromes, à vrai dire, tout le monde aime les palindromes. De ce fait, nous vous demandons de créer une commande <code>palindrome</code> qui prends en argument une chaîne de caractère et qui renvoie &quot;C'est un palindrome&quot; si la chaîne de caractère est un palindrome et &quot;Ce n'est pas un palindrome&quot; sinon. Par exemple, 
si on appelle la commande avec la chaîne de caractère <code>kayak</code> ou <code>racecar</code> on doit obtenir &quot;C'est un palindrome&quot; et si on appelle la commande avec la chaîne de caractère <code>hello</code> on doit obtenir &quot;Ce n'est pas un palindrome&quot;.</p>
<p>La structure de la commande est la suivante :</p>
<pre><code class="language-python">@bot.command()
async def palindrome(ctx : commands.Context, *, word : str) -&gt; None:
    ...
</code></pre>
<details>
  <summary>Solution</summary>
<pre><code class="language-python">@bot.command()
async def palindrome(ctx : commands.Context, *, word : str) -&gt; None:
    if word == word[::-1]:
        await ctx.send(&quot;C'est un palindrome&quot;)
    else:
        await ctx.send(&quot;Ce n'est pas un palindrome&quot;)
</code></pre>
<p>Conseil dans ce contexte, nous remarquons que la commande du palindrome est très similaire à la commande du reverse. Nous pouvons donc créer une fonction externe qui prends en argument une chaîne de caractère et qui renvoie la chaîne de caractère inversée. Ensuite, nous pouvons appeler cette fonction dans la commande du palindrome et dans la commande du reverse. Cela n'est pas obligatoire mais cela permet de réutiliser du code et de rendre le code plus lisible ce qui suit le principe DRY (Don't Repeat Yourself).</p>
</details><div style="break-before: page; page-break-before: always;"></div><h1 id="commands-errors"><a class="header" href="#commands-errors">commands errors</a></h1>
<p>Chaque commande peut lever une exception. Il est possible de gérer ces exceptions avec la méthode <code>error</code> de chaque commande. De ce fait chaque fonctiond de gestion d'erreurs d'une commande aura la forme suivante :</p>
<pre><code class="language-python">@command_name.error
async def command_name_error(ctx, error):
    ...
</code></pre>
<p>Par exemple pour la commande si on une commande qui prends en argument un membre et un nombre et qui envoie n fois le nom du membre, on aura la commande suivante :</p>
<pre><code class="language-python">@bot.command()
async def repeat(ctx, member, amount):
    for _ in range(amount):
        await ctx.send(member.name)
</code></pre>
<p>Si on appelle la commande <code>repeat</code> avec un nombre négatif, on aura une erreur idem si le membre n'est pas valide.Pour gérer cette erreur, on peut rajouter des erreurs dans la commande et les gérer avec la méthode <code>error</code> de la commande :</p>
<pre><code class="language-python">@bot.command()
async def repeat(ctx, member, amount):
    if amount &lt; 0:
        raise commands.BadArgument(&quot;The amount must be positive&quot;)
    if not isinstance(amount, int):
        raise commands.BadArgument(&quot;The amount must be an integer&quot;)

    if not isinstance(member, discord.Member):
        raise commands.MemberNotFound(member)

    for _ in range(amount):
        await ctx.send(member.name)

@repeat.error
async def repeat_errors(ctx, error):
    if isinstance(error, commands.BadArgument)
        return await ctx.send(error)
    if isinstance(error, commands.MemberNotFound)
        return await ctx.send(f&quot;The member {error.argument} does not exist&quot;)

    raise error

</code></pre>
<p>On peut donc voir que pour la commande <code>repeat</code>, on a deux types d'erreurs possibles : <code>commands.BadArgument</code> et <code>commands.MemberNotFound</code>. Pour chacune de ces erreurs, on a une fonction de gestion d'erreur qui gère l'erreur en fonction de son type. Si l'erreur n'est pas de type <code>commands.BadArgument</code> ou <code>commands.MemberNotFound</code>, on relève l'erreur.</p>
<p>Il ne faut pas oublier de relancer l'erreur si on ne la gère pas. Sinon, la commande ne renverra rien.</p>
<hr />
<h1 id="exercices-5"><a class="header" href="#exercices-5">Exercices</a></h1>
<h3 id="exercice-1-5"><a class="header" href="#exercice-1-5">Exercice 1</a></h3>
<p>Soit la commande suivante :</p>
<pre><code class="language-python">@bot.command()
async def give(ctx, member, amount):
    await ctx.send(f&quot;You gave {amount} to {member}&quot;)
</code></pre>
<p>Gérer les erreurs suivantes :</p>
<ul>
<li>Le cas où le membre n'existe pas (commands.MemberNotFound)</li>
<li>Le cas où l'argument <code>amount</code> n'est pas un entier (commands.BadArgument)</li>
<li>Le cas où l'argument <code>amount</code> est négatif (commands.BadArgument)</li>
</ul>
<details>
  <summary>Solution</summary>
<pre><code class="language-python">@bot.command()
async def give(ctx, member : discord.Member, amount : int):
    if amount &lt; 0:
        raise commands.BadArgument(&quot;The amount must be positive&quot;)
    if not isinstance(amount, int):
        raise commands.BadArgument(&quot;The amount must be an integer&quot;)

    if not isinstance(member, discord.Member):
        raise commands.MemberNotFound(member)


    await ctx.send(f&quot;You gave {amount} to {member}&quot;)

@give.error
async def give_error(ctx, error):
    if isinstance(error, commands.MemberNotFound):
        await ctx.send(f&quot;The member {error.argument} does not exist&quot;)
    elif isinstance(error, commands.BadArgument):
        await ctx.send(error)

    raise error

</code></pre>
</details><div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-3---bacic-converters"><a class="header" href="#chapter-3---bacic-converters">Chapter 3 - Bacic Converters</a></h1>
<p>Dans Python il existe ce que l'on appelle des annotations de type (Type Hint). Ces annotations sont seulement la pour faire comprendre à l'utilisateur quel type nous voulons pour une fonction, par exemple :</p>
<pre><code class="language-python">def add(a, b):
    return a + b
</code></pre>
<p>On ne sait pas quel type doit être mis pour a et b car cela fonctionne très bien pour les entiers, les flottants et les chaînes de caractères. Mais si on veut faire une fonction qui ne fonctionne qu'avec des entiers, on peut utiliser les annotations de type :</p>
<pre><code class="language-python">def add(a : int, b : int) -&gt; int:
    return a + b
</code></pre>
<p>Malheuresement, ces annotations ne sont pas vérifiées par Python, elles sont seulement là pour nous aider à comprendre le code. Néanmoins, dans discord.py il existe ce que l'on appelle des convertisseurs. Ces convertisseurs sont des types qui permettent de convertir une chaîne de caractères en un autre type (car par defaut un paramètre de commande discord est une chaîne de caractère). Ces convertisseurs sont utilisés pour les arguments des commandes. Par exemple, si on veut que notre commande <code>add</code> ne fonctionne qu'avec des entiers, on peut utiliser le convertisseur <code>int</code> :</p>
<pre><code class="language-python">@bot.command()
async def add(ctx : commands.Context, a : int, b : int) -&gt; discord.Message:
    return await ctx.send(str(a + b))
</code></pre>
<p>Ici nous pouvons voir plusieurs choses, tout d'abord il y a l'annotation de type du contexte (même sans cette annotation son type sera <code>commands.Context</code>), ensuite il y a les annotations de type des paramètres <code>a</code> et <code>b</code>. Ces annotations de type sont des convertisseurs, ici nous voulons que <code>a</code> et <code>b</code> soient des entiers. Enfin, nous avons l'annotation de type du retour de la fonction, ici nous voulons que la fonction renvoie un message discord (Cette annotation n'est pas un convertisseur mais seulement une indication de la valeur de retour).</p>
<p>Quand on utilise un convertisseur, si la conversion échoue, la commande ne sera pas exécutée et le message d'erreur par défaut sera envoyé.</p>
<hr />
<h1 id="exercices-6"><a class="header" href="#exercices-6">Exercices</a></h1>
<h3 id="exercice-1-6"><a class="header" href="#exercice-1-6">Exercice 1</a></h3>
<p>Créer une commande <code>double</code> qui prends comme unique argument un nombre entier. Cette commande doit renvoyer le double du nombre passé en argument.</p>
<details>
  <summary>Solution</summary>
<pre><code class="language-python">@bot.command()
async def double(ctx : commands.Context, number : int) -&gt; discord.Message:
    return await ctx.send(str(number * 2))
</code></pre>
<p>On a donc ici notre paramètre <code>number</code> qui a comme convertisseur <code>int</code>. Ce convertisseur va donc essayer de convertir la chaîne de caractère passée en argument en un entier. Si la conversion échoue, la commande ne sera pas exécutée et le message d'erreur par défaut sera envoyé.</p>
</details>
<h3 id="exercice-2-5"><a class="header" href="#exercice-2-5">Exercice 2</a></h3>
<p>Créer une commande <code>repeat</code> qui prends deux arguments : un entier <code>n</code> et une chaîne de caractère <code>text</code>. Cette commande doit renvoyer <code>text</code> répété <code>n</code> fois. Si <code>n</code> est négatif, la commande doit renvoyer un message d'erreur.</p>
<details>
    <summary>Solution</summary>
<pre><code class="language-python">@bot.command()
async def repeat(ctx : commands.Context, n : int, text : str) -&gt; discord.Message:
    if n &lt; 0:
        return await ctx.send(&quot;n must be positive&quot;)
    return await ctx.send(text * n)
</code></pre>
<p>Ici nous avons deux convertisseurs, <code>int</code> et <code>str</code>. Le premier convertit la chaîne de caractère en un entier et le second convertit la chaîne de caractère en une chaîne de caractère. On comprends donc que le second convertisseur n'est pas nécessaire car par défaut une chaîne de caractère est une chaîne de caractère. Mais il est toujours préférable d'ajouter les annotations de type pour que le code soit plus lisible.</p>
</details>
<h3 id="exercice-3-4"><a class="header" href="#exercice-3-4">Exercice 3</a></h3>
<p>Créer une commande <code>est_majeur</code> qui prends comme unique argument un âge. Cette commande doit renvoyer <code>True</code> si l'âge passé en argument est supérieur ou égal à 18 et <code>False</code> sinon.</p>
<details>
    <summary>Solution</summary>
<pre><code class="language-python">@bot.command()
async def est_majeur(ctx : commands.Context, age : int) -&gt; discord.Message:
    return await ctx.send(str(age &gt;= 18))
</code></pre>
<p>Ici nous avons un seul convertisseur, <code>int</code>. Ce convertisseur va donc essayer de convertir la chaîne de caractère passée en argument en un entier. Si la conversion échoue, la commande ne sera pas exécutée et le message d'erreur par défaut sera envoyé.</p>
</details>
<h3 id="exercice-4-4"><a class="header" href="#exercice-4-4">Exercice 4</a></h3>
<p>Créer une commande <code>is_ok</code> qui prends comme unique argument un booléen <code>ok</code>. Cette commande doit renvoyer &quot;Ok !&quot; si le booléen passé en argument est <code>True</code> et &quot;Not ok&quot; sinon.</p>
<details>
    <summary>Solution</summary>
<pre><code class="language-python">@bot.command()
async def is_ok(ctx : commands.Context, ok : bool) -&gt; discord.Message:
    return await ctx.send(&quot;Ok !&quot; if ok else &quot;Not ok&quot;)
</code></pre>
<p>ou bien</p>
<pre><code class="language-python">@bot.command()
async def is_ok(ctx : commands.Context, ok : bool) -&gt; discord.Message:
    if ok:
        return await ctx.send(&quot;Ok !&quot;)
    return await ctx.send(&quot;Not ok&quot;)
</code></pre>
<p>Ici nous avons un seul convertisseur, <code>bool</code>. Ce convertisseur va donc essayer de convertir la chaîne de caractère passée en argument en un booléen. Si la conversion échoue, la commande ne sera pas exécutée et le message d'erreur par défaut sera envoyé. Pour appeller la commande, on peut utiliser <code>True</code> ou <code>False</code> ou bien <code>1</code> ou <code>0</code>.</p>
</details>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-4---cogs"><a class="header" href="#chapter-4---cogs">Chapter 4 - Cogs</a></h1>
<p>Les cogs sont des extensions de commandes. Ils permettent de regrouper des commandes et des événements dans des fichiers séparés. Cela permet de mieux organiser son code et de le rendre plus lisible. Les cogs sont des classes qui héritent de la classe <code>commands.Cog</code>. Les commandes et les événements sont définis dans les méthodes de la classe. Les cogs sont ensuite enregistrés dans le bot à l'aide de la méthode <code>add_cog</code>.</p>
<p>Par exemple, nous allons créer un cog qui contient une commande <code>ping</code> et un événement <code>on_message</code>. Nous allons ensuite enregistrer ce cog dans le bot.</p>
<pre><code class="language-python">import discord
from discord.ext import commands

class PingCog(commands.Cog):
    def __init__(self, bot : commands.Bot):
        self.bot = bot

    @commands.command()
    async def ping(self, ctx : commands.Context) -&gt; discord.Message:
        return await ctx.send(&quot;pong&quot;)

    @commands.Cog.listener()
    async def on_message(self, message : discord.Message) -&gt; None:
        if message.content == &quot;ping&quot;:
            await message.channel.send(&quot;pong&quot;)


</code></pre>
<p>On peut voir que les commandes et les événements sont définis dans des méthodes de la classe. Les commandes sont définis avec la méthode <code>command</code> et les événements sont définis avec la méthode <code>listener</code>. Ces méthodes sont des décorateurs qui prennent en paramètre le nom de l'événement ou de la commande. Pour les événements, le nom de l'événement est le nom de la méthode sans le préfixe <code>on_</code>. Pour les commandes, le nom de la commande est le nom de la méthode.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="add-commands-to-a-cog"><a class="header" href="#add-commands-to-a-cog">add commands to a cog</a></h1>
<p>Nous avons vu dans le chapitre précédent comment créer un cog. Nous allons maintenant voir comment ajouter des commandes à ce cog. Nous allons créer un cog qui contient une commande <code>ping</code> qui ne prends pas d'arguments et qui renvoie <code>pong</code>.</p>
<pre><code class="language-python">import discord
from discord.ext import commands

class PingCog(commands.Cog):
    def __init__(self, bot : commands.Bot):
        self.bot = bot

    @commands.command()
    async def ping(self, ctx : commands.Context) -&gt; discord.Message:
        return await ctx.send(&quot;pong&quot;)

</code></pre>
<p>Nous pouvons donc voir que pour créer une nouvelle commande, nous devons utiliser la méthode <code>command</code> de la librairie <code>commands</code>. Cette méthode prend en paramètre optionnel le nom de la commande. La fonction qui est définie juste en dessous de cette méthode est la fonction qui sera appelée lorsque la commande sera exécutée. Cette fonction prend en paramètre le contexte de la commande et renvoie un message discord.</p>
<hr />
<h1 id="exercices-7"><a class="header" href="#exercices-7">Exercices</a></h1>
<h3 id="exercice-1-7"><a class="header" href="#exercice-1-7">Exercice 1</a></h3>
<p>Créez un cog <code>AddCog</code> qui contient une commande <code>add</code> qui prends deux arguments et qui renvoie la somme de ces deux arguments.</p>
<details>
<summary>Solution</summary>
<pre><code class="language-python">import discord
from discord.ext import commands

class AddCog(commands.Cog):
    def __init__(self, bot : commands.Bot):
        self.bot = bot

    @commands.command()
    async def add(self, ctx : commands.Context, a : int, b : int) -&gt; discord.Message:
        return await ctx.send(str(a + b))

</code></pre>
<p>On peut donc voir que pour créer une nouvelle commande, nous devons utiliser la méthode <code>command</code> de la librairie <code>commands</code>. La fonction définie en dessous de cette méthode prends quatre paramètres. Le premier paramètre est l'objet en lui même, le second paramètre est le contexte de la commande, les paramètres suivants sont les arguments de la commande. On peut voir que les arguments sont définis avec un type. Les types des arguments sont vérifiés automatiquement par la librairie <code>commands</code> et si un argument n'est pas du bon type, la commande ne sera pas exécutée et un message d'erreur sera envoyé dans la console.</p>
</details>
<h3 id="exercice-2-6"><a class="header" href="#exercice-2-6">Exercice 2</a></h3>
<p>Créer un Cog <code>MentionCog</code> qui contient une commande <code>mention_member_in_channel</code> qui prends en paramètre un membre et un salon et qui envoie un message dans ce salon en mentionnant le membre. Cette commande prends donc deux paramètres et doit avoir la structure suivante :</p>
<pre><code class="language-python">async def mention(self,
                  ctx : commands.Context, 
                  member : discord.Member, 
                  channel : discord.TextChannel) -&gt; discord.Message:
</code></pre>
<details>
<summary>Solution</summary>
<pre><code class="language-python">import discord
from discord.ext import commands

class MentionCog(commands.Cog):
    def __init__(self, bot : commands.Bot):
        self.bot = bot

    @commands.command()
    async def mention_member_in_channel(self, 
                                        ctx : commands.Context, 
                                        member : discord.Member, 
                                        channel : discord.TextChannel) -&gt; discord.Message:
        return await channel.send(member.mention)

</code></pre>
</details>
<h3 id="exercice-3-5"><a class="header" href="#exercice-3-5">Exercice 3</a></h3>
<p>Créer un Cog <code>MemberMuteCog</code> qui va contenir deux commandes, une commande <code>mute_member</code> qui prends en paramètre un membre et qui mute ce membre et une commande <code>unmute_member</code> qui prends en paramètre un membre et qui unmute ce membre.</p>
<p>Les deux commandes doivent avoir la structure suivante :</p>
<pre><code class="language-python">async def mute_member(self, 
                      ctx : commands.Context, 
                      member : discord.Member) -&gt; discord.Message:
</code></pre>
<pre><code class="language-python">async def unmute_member(self, 
                        ctx : commands.Context, 
                        member : discord.Member) -&gt; discord.Message:
</code></pre>
<details>
<summary>Solution</summary>
<pre><code class="language-python">import discord
from discord.ext import commands

class MemberMuteCog(commands.Cog):
    def __init__(self, bot : commands.Bot):
        self.bot = bot

    @commands.command()
    async def mute_member(self, 
                          ctx : commands.Context, 
                          member : discord.Member) -&gt; discord.Message:
        await member.edit(mute = True)
        return await ctx.send(f&quot;{member.mention} a été mute&quot;)

    @commands.command()
    async def unmute_member(self, 
                            ctx : commands.Context, 
                            member : discord.Member) -&gt; discord.Message:
        await member.edit(mute = False)
        return await ctx.send(f&quot;{member.mention} a été unmute&quot;)

</code></pre>
</details>
<h3 id="exercice-4-5"><a class="header" href="#exercice-4-5">Exercice 4</a></h3>
<p>Créer un Cog <code>MemberRoleHandlerCog</code> qui va contenir deux commandes, une commande <code>add_role_to_member</code> qui prends en paramètre un membre et un rôle et qui ajoute ce rôle au membre et une commande <code>remove_role_from_member</code> qui prends en paramètre un membre et un rôle et qui retire ce rôle au membre.</p>
<p>Les deux commandes doivent avoir la structure suivante :</p>
<pre><code class="language-python">async def add_role_to_member(self,
                             ctx : commands.Context,
                             member : discord.Member,
                             role : discord.Role) -&gt; discord.Message:
</code></pre>
<pre><code class="language-python">async def remove_role_from_member(self,
                             ctx : commands.Context,
                             member : discord.Member,
                             role : discord.Role) -&gt; discord.Message:
</code></pre>
<details>
<summary>Solution</summary>
<pre><code class="language-python">import discord
from discord.ext import commands

class MemberRoleHandlerCog(commands.Cog):
    def __init__(self, bot : commands.Bot):
        self.bot = bot

    @commands.command()
    async def add_role_to_member(self, 
                                 ctx : commands.Context, 
                                 member : discord.Member, 
                                 role : discord.Role) -&gt; discord.Message:
        await member.add_roles(role)
        return await ctx.send(f&quot;{role.mention} a été ajouté à {member.mention}&quot;)

    @commands.command()
    async def remove_role_from_member(self, 
                                      ctx : commands.Context, 
                                      member : discord.Member, 
                                      role : discord.Role) -&gt; discord.Message:
        await member.remove_roles(role)
        return await ctx.send(f&quot;{role.mention} a été retiré de {member.mention}&quot;)

</code></pre>
</details>
<br>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="add-events-to-a-cog"><a class="header" href="#add-events-to-a-cog">add events to a cog</a></h1>
<p>Les évènements dans les Cogs sont définis à l'aide du décorateur <code>commands.Cog.listener</code>. Ce décorateur prend en paramètre optionnel le nom de l'évènement. Si le nom de l'évènement n'est pas spécifié, le nom de la méthode sera utilisé comme nom de l'évènement. Par exemple, la méthode <code>on_message</code> sera appelée lorsqu'un message est envoyé dans un salon.</p>
<pre><code class="language-python">import discord
from discord.ext import commands

class PingCog(commands.Cog):
    def __init__(self, bot : commands.Bot):
        self.bot = bot

    @commands.Cog.listener()
    async def on_message(self, message : discord.Message) -&gt; None:
        if message.content == &quot;ping&quot;:
            await message.channel.send(&quot;pong&quot;)

</code></pre>
<p>On voit que la méthode <code>on_message</code> prend en paramètre le message envoyé et qu'elle est considérée comme un Cog car elle a le décorateur <code>commands.Cog.listener</code>. On peut voir que le nom de l'évènement est <code>on_message</code> car le nom de la méthode est <code>on_message</code>.</p>
<p>On peut aussi définir un évènement sans le nom de la méthode. Dans ce cas, le nom de l'évènement sera le nom de la méthode sans le préfixe <code>on_</code>. Par exemple, la méthode <code>message</code> sera appelée lorsqu'un message est envoyé dans un salon.</p>
<pre><code class="language-python">import discord
from discord.ext import commands

class PingCog(commands.Cog):
    def __init__(self, bot : commands.Bot):
        self.bot = bot

    @commands.Cog.listener(&quot;on_message&quot;)
    async def message(self, message : discord.Message) -&gt; None:
        if message.content == &quot;ping&quot;:
            await message.channel.send(&quot;pong&quot;)

</code></pre>
<p>On voit que la méthode <code>message</code> prend en paramètre le message envoyé et qu'elle est considérée comme un Cog car elle a le décorateur <code>commands.Cog.listener</code>. On peut voir que le nom de l'évènement est <code>on_message</code> car le nom de la méthode est <code>message</code>.</p>
<hr />
<h1 id="exercices-8"><a class="header" href="#exercices-8">Exercices</a></h1>
<h3 id="exercice-1-8"><a class="header" href="#exercice-1-8">Exercice 1</a></h3>
<p>Créer un Cog <code>CountCog</code> qui contient dans son constructeur un attribut <code>count</code> qui est initialisé à 0. Ce Cog doit avoir un évènement <code>on_message</code> qui incrémente l'attribut <code>count</code> à chaque fois qu'un message est envoyé dans un salon. Le Cog doit aussi avoir une commande <code>count</code> qui affiche la valeur de l'attribut <code>count</code>.</p>
<p>L'évènement et la commande auront donc la structure suivante :</p>
<pre><code class="language-python">@commands.Cog.listener()
async def on_message(self, message : discord.Message) -&gt; None:
    ...
</code></pre>
<pre><code class="language-python">@commands.command()
async def count(self, ctx : commands.Context) -&gt; discord.Message:
    ...
</code></pre>
<details>
<summary>Solution</summary>
<pre><code class="language-python">import discord
from discord.ext import commands

class CountCog(commands.Cog):
    def __init__(self, bot : commands.Bot):
        self.bot = bot
        self.count = 0

    @commands.Cog.listener()
    async def on_message(self, message : discord.Message) -&gt; None:
        self.count += 1

    @commands.command()
    async def count(self, ctx : commands.Context) -&gt; discord.Message:
        return await ctx.send(f&quot;count: {self.count}&quot;)

</code></pre>
</details>
<h3 id="exercice-2-7"><a class="header" href="#exercice-2-7">Exercice 2</a></h3>
<p>Créer un Cog <code>Welcome</code> qui contient dans son constructeur un attribut <code>welcome_channel</code> qui est initialisé à <code>None</code>. Ce Cog doit avoir un évènement <code>on_member_join</code> qui envoie un message de bienvenue dans le salon <code>welcome_channel</code> si celui-ci est défini. Le Cog doit aussi avoir une commande <code>set_welcome_channel</code> qui permet de définir le salon de bienvenue.</p>
<p>L'évènement et la commande auront donc la structure suivante :</p>
<pre><code class="language-python">@commands.Cog.listener()
async def on_member_join(self, member : discord.Member) -&gt; None:
    ...
</code></pre>
<pre><code class="language-python">@commands.command()
async def set_welcome_channel(self, 
                              ctx : commands.Context,
                              channel : discord.TextChannel) -&gt; discord.Message:
    ...
</code></pre>
<details>
<summary>Solution</summary>
<pre><code class="language-python">import discord
from discord.ext import commands

class Welcome(commands.Cog):
    def __init__(self, bot : commands.Bot):
        self.bot = bot
        self.welcome_channel = None

    @commands.Cog.listener()
    async def on_member_join(self, member : discord.Member) -&gt; None:
        if self.welcome_channel is not None:
            await self.welcome_channel.send(f&quot;Welcome {member.mention}!&quot;)

    @commands.command()
    async def set_welcome_channel(self, 
                                  ctx : commands.Context, 
                                  channel : discord.TextChannel) -&gt; discord.Message:
        self.welcome_channel = channel
        return await ctx.send(f&quot;Welcome channel set to {channel.mention}&quot;)

</code></pre>
</details>
<h3 id="exercice-3-6"><a class="header" href="#exercice-3-6">Exercice 3</a></h3>
<p>Maintenant que l'on dit bienvenue aux nouveaux membres, on va leur donner un rôle. Créer un Cog <code>Role</code> qui contient dans son constructeur un attribut <code>role</code> qui est initialisé à <code>None</code>. Ce Cog doit avoir un évènement <code>on_member_join</code> qui donne le rôle <code>role</code> au nouveau membre si celui-ci est défini. Le Cog doit aussi avoir une commande <code>set_role</code> qui permet de définir le rôle à donner.</p>
<p>L'évènement et la commande auront donc la structure suivante :</p>
<pre><code class="language-python">@commands.Cog.listener()
async def on_member_join(self, member : discord.Member) -&gt; None:
    ...
</code></pre>
<pre><code class="language-python">@commands.command()
async def set_role(self, 
                   ctx : commands.Context, 
                   role : discord.Role) -&gt; discord.Message:
    ...
</code></pre>
<details>
<summary>Solution</summary>
<pre><code class="language-python">import discord
from discord.ext import commands

class Role(commands.Cog):
    def __init__(self, bot : commands.Bot):
        self.bot = bot
        self.role = None

    @commands.Cog.listener()
    async def on_member_join(self, member : discord.Member) -&gt; None:
        if self.role is not None:
            await member.add_roles(self.role)

    @commands.command()
    async def set_role(self, 
                       ctx : commands.Context, 
                       role : discord.Role) -&gt; discord.Message:
        self.role = role
        return await ctx.send(f&quot;Role set to {role.mention}&quot;)

</code></pre>
</details>
<h3 id="exercice-4-6"><a class="header" href="#exercice-4-6">Exercice 4</a></h3>
<p>Notre nouveau membre vient de partir, on va donc lui envoyer un message de départ. Créer un Cog <code>Goodbye</code> qui contient dans son constructeur un attribut <code>goodbye_channel</code> qui est initialisé à <code>None</code>. Ce Cog doit avoir un évènement <code>on_member_remove</code> qui envoie un message de départ dans le salon <code>goodbye_channel</code> si celui-ci est défini. Le Cog doit aussi avoir une commande <code>set_goodbye_channel</code> qui permet de définir le salon de départ.</p>
<p>L'évènement et la commande auront donc la structure suivante :</p>
<pre><code class="language-python">@commands.Cog.listener()
async def on_member_remove(self, member : discord.Member) -&gt; None:
    ...
</code></pre>
<pre><code class="language-python">@commands.command()
async def set_goodbye_channel(self, 
                              ctx : commands.Context, 
                              channel : discord.TextChannel) -&gt; discord.Message:
    ...
</code></pre>
<details>
<summary>Solution</summary>
<pre><code class="language-python">import discord
from discord.ext import commands

class Goodbye(commands.Cog):
    def __init__(self, bot : commands.Bot):
        self.bot = bot
        self.goodbye_channel = None

    @commands.Cog.listener()
    async def on_member_remove(self, member : discord.Member) -&gt; None:
        if self.goodbye_channel is not None:
            await self.goodbye_channel.send(f&quot;Goodbye {member.mention}!&quot;)

    @commands.command()
    async def set_goodbye_channel(self, 
                                  ctx : commands.Context, 
                                  channel : discord.TextChannel) -&gt; discord.Message:
        self.goodbye_channel = channel
        return await ctx.send(f&quot;Goodbye channel set to {channel.mention}&quot;)

</code></pre>
</details>
<br>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-5---embeds"><a class="header" href="#chapter-5---embeds">Chapter 5 - Embeds</a></h1>
<p>Les embeds sont des messages plus complexes que les messages simples. Ils permettent d'ajouter des titres, des descriptions, des images, des liens, des couleurs, des champs, des pieds de page, etc. Les embeds sont des objets de la classe <code>discord.Embed</code>. Ils sont ensuite envoyés dans un salon à l'aide de la méthode <code>send</code>.</p>
<pre><code class="language-python">@bot.command
async def embed(ctx):
    embed = discord.Embed(title=&quot;Titre&quot;, description=&quot;Description&quot;)
    return await ctx.send(embed=embed)
</code></pre>
<p>Dans cet exemple, nous créons un embed avec un titre et une description. Nous envoyons ensuite cet embed dans le salon dans lequel la commande a été exécutée.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="create-an-embed"><a class="header" href="#create-an-embed">create an embed</a></h1>
<p>Pour créer un embed nous devons d'abord créer un objet de la classe <code>discord.Embed</code>. Nous pouvons ensuite ajouter des informations à cet objet. Nous pouvons ajouter un titre, une description, une image, un lien, une couleur, un champ, un pied de page, etc. Nous pouvons ensuite envoyer cet embed dans un salon à l'aide de la méthode <code>send</code>.</p>
<p>Son constructeur prend en paramètre plusieurs arguments optionnels. Nous pouvons par exemple définir le titre, la description, la couleur, etc. Nous pouvons également définir le titre, la description, la couleur, etc... en utilisant les méthodes <code>set_title</code>, <code>set_description</code>, <code>set_color</code>, etc...</p>
<pre><code class="language-python">embed = discord.Embed(title=&quot;Titre&quot;, description=&quot;Description&quot;)
</code></pre>
<p>Va créer un embed avec un titre et une description nommés &quot;Titre&quot; et &quot;Description&quot;.</p>
<hr />
<h1 id="exercices-9"><a class="header" href="#exercices-9">Exercices</a></h1>
<h3 id="exercice-1-9"><a class="header" href="#exercice-1-9">Exercice 1</a></h3>
<p>Créez un embed avec un titre et une description. Envoyez cet embed dans le salon dans lequel la commande a été exécutée. La commande doit avoir la structure suivante :</p>
<pre><code class="language-python">@bot.command()
async def embed(ctx):
    ...
</code></pre>
<details>
<summary>Solution</summary>
<pre><code class="language-python">@bot.command()
async def embed(ctx):
    embed = discord.Embed(title=&quot;Titre&quot;, description=&quot;Description&quot;)
    return await ctx.send(embed=embed)
</code></pre>
</details>
<h3 id="exercice-2-8"><a class="header" href="#exercice-2-8">Exercice 2</a></h3>
<p>Créer une commande &quot;Hello&quot; qui prends en argument un membre et qui doit renvoyer un embed avec comme titre &quot;Hello new member&quot; et comme description &quot;Welcome to the server member.name&quot;. La commande doit avoir la structure suivante :</p>
<pre><code class="language-python">@bot.command() 
async def hello(ctx, member : discord.Member):
    ...
</code></pre>
<details>
<summary>Solution</summary>
<pre><code class="language-python">@bot.command()
async def hello(ctx, member : discord.Member):
    embed = discord.Embed(title=&quot;Hello new member&quot;, description=f&quot;Welcome to the server {member.name}&quot;)
    return await ctx.send(embed=embed)
</code></pre>
</details>
<h3 id="exercice-3-7"><a class="header" href="#exercice-3-7">Exercice 3</a></h3>
<p>Créer une commandes <code>member_roles</code> qui prends en argument un membre et qui doit renvoyer un embed avec comme titre &quot;Roles&quot; et comme description la liste des rôles du membre. La commande doit avoir la structure suivante :</p>
<pre><code class="language-python">@bot.command()
async def member_roles(ctx, member : discord.Member):
    ...
</code></pre>
<details>
<summary>Solution</summary>
<pre><code class="language-python">@bot.command()
async def member_roles(ctx, member : discord.Member):
    embed = discord.Embed(title=&quot;Roles&quot;, description=&quot;\n&quot;.join([role.name for role in member.roles]))
    return await ctx.send(embed=embed)
</code></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="customize-an-embed"><a class="header" href="#customize-an-embed">customize an embed</a></h1>
<p>Il est possible de personnaliser un embed en modifiant ses attributs. Pour cela, on utilise les méthodes <code>set_author</code>, <code>set_footer</code>, <code>set_image</code>, <code>set_thumbnail</code>, <code>set_title</code> et <code>set_description</code>. Ces méthodes prennent en paramètre le nom de l'attribut et sa valeur. Par exemple, pour changer la couleur d'un embed, on utilise la méthode <code>set_color</code> qui prends en paramètre la couleur de l'embed. Pour obtenir la couleur d'un membre, on utilise l'attribut <code>color</code> du membre (member.color).</p>
<pre><code class="language-python">embed = discord.Embed()
embed.set_color(member.color)
</code></pre>
<p>Si on veut, par exemple définir la thumbnail avec l'avatar d'un membre, on peut utiliser l'attribut <code>avatar.url</code> du membre (member.avatar.url).</p>
<pre><code class="language-python">embed = discord.Embed()
embed.set_thumbnail(url=member.avatar.url)
</code></pre>
<p>Pour ajouter un champ à un embed, on utilise la méthode <code>add_field</code> qui prends en paramètre le nom du champ et sa valeur.</p>
<pre><code class="language-python">embed = discord.Embed()
embed.add_field(name=&quot;Champ 1&quot;, value=&quot;Valeur 1&quot;)
embed.add_field(name=&quot;Champ 2&quot;, value=&quot;Valeur 2&quot;)
</code></pre>
<hr />
<h1 id="exercices-10"><a class="header" href="#exercices-10">Exercices</a></h1>
<h3 id="exercice-1-10"><a class="header" href="#exercice-1-10">Exercice 1</a></h3>
<p>Créer une commande <code>beautify</code> qui prends en paramètre un message et qui renvoie un embed avec comme titre &quot;Message de {auteur du message}&quot;, comme description le contenu du message et comme couleur la couleur de l'auteur du message. La commande doit avoir la structure suivante :</p>
<pre><code class="language-python">@bot.command()
async def beautify(ctx : commands.Context, *, message : str) -&gt; None:
    ...
</code></pre>
<details>
  <summary>Solution</summary>
<pre><code class="language-python">@bot.command()
async def beautify(ctx : commands.Context, *, message : str) -&gt; None:
    embed = discord.Embed(title=f&quot;Message de {ctx.author.display_name}&quot;, description=message, color=ctx.author.color)
    return await ctx.send(embed=embed)
</code></pre>
</details>
<h3 id="exercice-2-9"><a class="header" href="#exercice-2-9">Exercice 2</a></h3>
<p>Certains de nos membres ont des avatars absolument magnifiques et on aimerait pouvoir les afficher dans un embed. Pour cela, on va créer une commande <code>avatar</code> qui prends en paramètre optionnel un membre et qui renvoie un embed contenant l'avatar du membre spécifié dans l'image de l'embed et le lien vers cette image dans la description de l'embed. Si le membre n'est pas spécifié, la commande doit renvoyer l'avatar de l'auteur de la commande. Pour obtenir l'avatar d'un membre, il faut utiliser l'attribut <code>avatar.url</code> du membre (member.avatar.url). Pour créer un embed, il faut utiliser la classe <code>discord.Embed</code> et pour ajouter une image à un embed, il faut utiliser la méthode <code>set_image</code> de la classe <code>discord.Embed</code> (embed.set_image).</p>
<p>La structure de la commande est la suivante :</p>
<pre><code class="language-python">@bot.command()
async def avatar(ctx : commands.Context, member : discord.Member = None) -&gt; None:
    ...
</code></pre>
<details>
  <summary>Solution</summary>
<pre><code class="language-python">@bot.command()
async def avatar(ctx : commands.Context, member : discord.Member = None) -&gt; None:
    if member is None:
        member = ctx.author

    embed = discord.Embed()
    embed.set_image(url=member.avatar.url)
    embed.description = member.avatar.url
    await ctx.send(embed=embed)
</code></pre>
</details>
<h3 id="exercice-3-8"><a class="header" href="#exercice-3-8">Exercice 3</a></h3>
<p>On souhaite créer une commande <code>server</code> qui renvoie un embed contenant le nom du serveur, le nombre de membres, le nombre de rôles et le nombre de salons. Pour obtenir ces informations, il faut utiliser les attributs <code>name</code>, <code>member_count</code>, <code>role_count</code> et <code>text_channels</code> du serveur (ctx.guild). Pour créer un embed, il faut utiliser la classe <code>discord.Embed</code> et pour ajouter une image à un embed, il faut utiliser la méthode <code>set_image</code> de la classe <code>discord.Embed</code> (embed.set_image).</p>
<p>La structure de la commande est la suivante :</p>
<pre><code class="language-python">@bot.command()
async def server(ctx : commands.Context) -&gt; None:
    ...
</code></pre>
<details>
  <summary>Solution</summary>
<pre><code class="language-python">@bot.command()
async def server(ctx : commands.Context) -&gt; None:
    embed = discord.Embed()
    embed.title = ctx.guild.name
    embed.description = f&quot;Members: {ctx.guild.member_count}\nRoles: {ctx.guild.role_count}\nChannels: {len(ctx.guild.text_channels)}&quot;
    await ctx.send(embed=embed)
</code></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-6---slash-commands"><a class="header" href="#chapter-6---slash-commands">Chapter 6 - Slash Commands</a></h1>
<p>Les slash commands sont des commandes qui sont affichées dans la barre de commande de discord. Elles sont très pratiques car elles permettent de ne pas avoir à taper de préfixe pour lancer une commande. Elles sont aussi plus visibles que les commandes classiques. Pour créer une slash command, on utilise la syntaxe suivante :</p>
<pre><code class="language-python">@bot.tree.command()
async def command_name(interaction : discord.Interaction, *args, **kwargs):
    ...
</code></pre>
<p>Par exemple, pour créer une slash command <code>ping</code> qui est appelée lorsque l'utilisateur exécute la commande <code>/ping</code>, on utilise la syntaxe suivante :</p>
<pre><code class="language-python">@bot.tree.command()
async def ping(interaction : discord.Interaction):
    await ctx.send(&quot;Pong !&quot;)
</code></pre>
<p>Cet exemple envoie le message &quot;Pong !&quot; dans le salon dans lequel la commande a été exécutée.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="create-a-slash-command"><a class="header" href="#create-a-slash-command">create a slash command</a></h1>
<hr />
<h1 id="exercices-11"><a class="header" href="#exercices-11">Exercices</a></h1>
<h3 id="exercice-1-11"><a class="header" href="#exercice-1-11">Exercice 1</a></h3>
<p>Créer une slash command <code>shop</code> qui prends trois arguments : une chaîne de caractère <code>article</code>, une entier <code>quantity</code> et une action qui est un litéral entre &quot;buy&quot; et &quot;sell&quot;. Si l'action est &quot;buy&quot;, la commande renvoie &quot;You bought {quantity} {article}&quot;. Si l'action est &quot;sell&quot;, la commande renvoie &quot;You sold {quantity} {article}&quot;. Si l'action est autre chose, la commande renvoie une erreur.</p>
<p>Pour créer un litéral, il faut utiliser la fonction <code>Literal</code> de la librairie <code>typing</code> comme ceci :</p>
<pre><code class="language-python">from typing import Literal

action : Literal[&quot;buy&quot;, &quot;sell&quot;]
</code></pre>
<details>
  <summary>Solution</summary>
<pre><code class="language-python">@bot.tree.command()
async def shop(interaction : discord.Interaction, article : str, quantity : int, action : Literal[&quot;buy&quot;, &quot;sell&quot;]) -&gt; None:
    if action == &quot;buy&quot;:
        await interaction.response.send_message(f&quot;You bought {quantity} {article}&quot;)
    elif action == &quot;sell&quot;:
        await interaction.response.send_message(f&quot;You sold {quantity} {article}&quot;)
    else:
        raise commands.BadArgument(&quot;action must be 'buy' or 'sell'&quot;)

</code></pre>
</details>
<h3 id="exercice-2-10"><a class="header" href="#exercice-2-10">Exercice 2</a></h3>
<p>Créer une commande <code>add</code> qui prends deux arguments de type <code>app_command.Range[int, 0, 100]</code> et qui renvoie la somme des deux nombres. Si l'un des deux nombres est en dehors de l'intervalle [0, 100], la commande renvoie une erreur.</p>
<details>
  <summary>Solution</summary>
<pre><code class="language-python">@bot.tree.command()
async def add(interaction : discord.Interaction, number1 : app_command.Range[int, 0, 100], number2 : app_command.Range[int, 0, 100]) -&gt; None:
    await interaction.response.send_message(number1 + number2)
</code></pre>
</details>
<h3 id="exercice-3-9"><a class="header" href="#exercice-3-9">Exercice 3</a></h3>
<p>Soit l'enum suivante :</p>
<pre><code class="language-python">class Color(Enum):
    RED = &quot;red&quot;
    GREEN = &quot;green&quot;
    BLUE = &quot;blue&quot;
</code></pre>
<p>Créer une commande <code>color</code> qui prends un argument de type <code>Color</code> et qui renvoie la couleur choisie.</p>
<details>
  <summary>Solution</summary>
<pre><code class="language-python">@bot.tree.command()
async def color(interaction : discord.Interaction, color : Color) -&gt; None:
    await interaction.response.send_message(color.value)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-7---hybrid-commands"><a class="header" href="#chapter-7---hybrid-commands">Chapter 7 - Hybrid Commands</a></h1>
<p>Les commandes hybrides sont des commandes qui sont affichées dans la barre de commande de discord et qui peuvent être exécutées avec un préfixe. Elles sont très pratiques car elles permettent de ne pas avoir à taper de préfixe pour lancer une commande. Elles sont aussi plus visibles que les commandes classiques. Pour créer une hybrid command, on utilise la syntaxe suivante :</p>
<pre><code class="language-python">@bot.hybrid_command()
async def command_name(ctx : commands.Context, *args, **kwargs):
    ...
</code></pre>
<p>Par exemple, pour créer une hybrid command <code>ping</code> qui est appelée lorsque l'utilisateur exécute la commande <code>/ping</code> ou <code>!ping</code>, on utilise la syntaxe suivante :</p>
<pre><code class="language-python">@bot.hybrid_command()
async def ping(ctx : commands.Context):
    await ctx.send(&quot;Pong !&quot;)
</code></pre>
<p>Cet exemple envoie le message &quot;Pong !&quot; dans le salon dans lequel la commande a été exécutée. On voit que cela est très pratique car on a encore le contexte de la commande et on peut donc utiliser les méthodes de <code>discord.ext.commands.Context</code>.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="create-a-hybrid-command"><a class="header" href="#create-a-hybrid-command">create a hybrid command</a></h1>
<p>Comme on l'a vu dans la section précédente, pour créer une hybrid command, on utilise la syntaxe suivante :</p>
<pre><code class="language-python">@bot.hybrid_command()
async def command_name(ctx : commands.Context, *args, **kwargs):
    ...
</code></pre>
<hr />
<h1 id="exercices-12"><a class="header" href="#exercices-12">Exercices</a></h1>
<h3 id="exercice-1-12"><a class="header" href="#exercice-1-12">Exercice 1</a></h3>
<p>Créer une commande hybride <code>announcement</code> qui prends en paramètre un titre et un message et qui renvoie un embed avec comme titre notre titre, comme description &quot;Nouvelle annonce&quot; et un champ &quot;Message&quot; avec comme valeur notre message. Pour créer un champ dans un embed, il faut utiliser la méthode <code>add_field</code> de la classe <code>discord.Embed</code> (embed.add_field). On devra définir l'auteur de l'embed avec l'auteur de la commande et la couleur de l'embed avec la couleur de l'auteur de la commande (ctx.author.color). La thumbnail de l'embed sera l'icone de la guilde (ctx.guild.icon.url).</p>
<p>La commande doit être de la forme suivante :</p>
<pre><code class="language-python">@bot.hybrid_command()
async def announcement(ctx : commands.Context, title : str, *, message : str) -&gt; discord.Message:
    ...
</code></pre>
<details>
  <summary>Solution</summary>
<pre><code class="language-python">@bot.hybrid_command()
async def announcement(ctx : commands.Context, title : str, *, message : str) -&gt; discord.Message:
    embed = discord.Embed(title=title, description=&quot;Nouvelle annonce&quot;, color=ctx.author.color)
    embed.set_author(name=ctx.author.display_name, icon_url=ctx.author.avatar.url)
    embed.set_thumbnail(url=ctx.guild.icon.url)
    embed.add_field(name=&quot;Message&quot;, value=message)
    return await ctx.send(embed=embed)
</code></pre>
</details><div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-8---converters"><a class="header" href="#chapter-8---converters">Chapter 8 - Converters</a></h1>
<p>Les convertisseurs sont des fonctions qui permettent de convertir une chaîne de caractères en un autre type. Par exemple, on peut convertir une chaîne de caractères en entier, en booléen, en date, en heure, en membre, en rôle, en salon, en emoji, en couleur, en URL, en fichier, en utilisateur, en chaîne de caractères, etc. Les convertisseurs sont très utiles car ils permettent de vérifier que les arguments passés à une commande sont valides. Par exemple, si on veut créer une commande qui permet de bannir un membre, on peut utiliser le convertisseur <code>discord.Member</code> pour vérifier que le membre existe et que le bot a les permissions nécessaires pour bannir ce membre. Si le membre n'existe pas ou si le bot n'a pas les permissions nécessaires, la commande renverra une erreur. Les convertisseurs sont des fonctions qui prennent en paramètre une chaîne de caractères et qui renvoient un objet de type <code>discord.ext.commands.Converter</code>. Les convertisseurs sont utilisés dans les commandes. Par exemple, pour créer une commande qui permet de bannir un membre, on peut utiliser le convertisseur <code>discord.Member</code> comme ceci :</p>
<pre><code class="language-python">@bot.command()
async def ban(ctx : commands.Context, member : discord.Member) -&gt; None:
    await member.ban()
</code></pre>
<p>Ici, le paramètre <code>member</code> est un convertisseur. Ce convertisseur va essayer de convertir la chaîne de caractères passée en argument en un membre. Si la conversion échoue, la commande ne sera pas exécutée et le message d'erreur par défaut sera envoyé.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions-converters"><a class="header" href="#functions-converters">functions converters</a></h1>
<hr />
<h1 id="exercices-13"><a class="header" href="#exercices-13">Exercices</a></h1>
<h3 id="exercice-1-13"><a class="header" href="#exercice-1-13">Exercice 1</a></h3>
<p>Créer un converter qui prends en paramètre une chaîne de caractère et qui renvoie la même chaîne en majuscule. Si la chaîne de caractère est vide, le converter doit renvoyer une erreur.</p>
<p>La structure du converter est la suivante :</p>
<pre><code class="language-python">def to_upper(argument : str) -&gt; str:
    ...
</code></pre>
<p>Un exemple d'utilisation du converter est le suivant :</p>
<pre><code class="language-python">@bot.command()
async def upper(ctx : commands.Context, argument : to_upper) -&gt; None:
    await ctx.send(argument)
</code></pre>
<p>Si on appel la commande <code>upper</code> avec la chaîne de caractère &quot;hello&quot;, le bot renvoie &quot;HELLO&quot;.</p>
<details>
  <summary>Solution</summary>
<pre><code class="language-python">def to_upper(argument : str) -&gt; str:
    if argument == &quot;&quot;:
        raise commands.BadArgument(&quot;argument is empty&quot;)
    return argument.upper()
</code></pre>
</details>
<h3 id="exercice-2-11"><a class="header" href="#exercice-2-11">Exercice 2</a></h3>
<p>Créer un converter qui prends en paramètre un nombre et qui renvoie la chaîne de caractère qui suit la logique suivante : Si on prends 4 comme exemple, le converter renvoie &quot;1, 2, 3, 4&quot;. Si on prends 0 comme exemple, le converter renvoie &quot;0&quot;. Si on prends un nombre négatif, le converter renvoie une erreur. Donc la forme générale est la suivante : &quot;1, 2, 3, ..., n&quot; où n est le nombre passé en paramètre.</p>
<p>La structure du converter est la suivante :</p>
<pre><code class="language-python">def to_list(argument : int) -&gt; str:
    ...
</code></pre>
<p>Un exemple d'utilisation du converter est le suivant :</p>
<pre><code class="language-python">@bot.command()
async def list_convertion(ctx : commands.Context, argument : to_list) -&gt; None:
    await ctx.send(argument)
</code></pre>
<p>Si on appel la commande <code>list_convertion</code> avec le nombre 4, le bot renvoie &quot;1, 2, 3, 4&quot;.</p>
<details>
  <summary>Solution</summary>
<pre><code class="language-python">def to_list(argument : int) -&gt; str:
    if argument &lt; 0:
        raise commands.BadArgument(&quot;argument must be positive&quot;)
    return &quot;, &quot;.join(str(i) for i in range(1, argument + 1))
</code></pre>
</details>
<h3 id="exercice-3-10"><a class="header" href="#exercice-3-10">Exercice 3</a></h3>
<p>Créer un converter qui prends en paramètre un membre et qui doit renvoyer la chaîne qui a la forme &quot;Hello, member.name !&quot; où member.name est le nom du membre passé en paramètre. </p>
<p>La structure du converter est la suivante :</p>
<pre><code class="language-python">def to_hello(member : discord.Member) -&gt; str:
    ...
</code></pre>
<p>Un exemple d'utilisation du converter est le suivant :</p>
<pre><code class="language-python">@bot.command()
async def hello(ctx : commands.Context, member : to_hello) -&gt; None:
    await ctx.send(member)
</code></pre>
<p>Si on appel la commande <code>hello</code> avec le membre &quot;John&quot;, le bot renvoie &quot;Hello, John !&quot;.</p>
<details>
  <summary>Solution</summary>
<pre><code class="language-python">def to_hello(member : discord.Member) -&gt; str:
    return f&quot;Hello, {member.name} !&quot;
</code></pre>
</details>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-converters"><a class="header" href="#advanced-converters">advanced converters</a></h1>
<p>Il existe aussi les converters avancés, qui sont des converters qui héritent de <code>commands.Converter</code>. Ces converters sont plus complexes à créer, mais ils permettent de créer des converters plus personnalisés. Par exemple, on peut créer un converter qui prends en paramètre un membre et qui renvoie un message de la forme &quot;Le membre {membre} a été banni&quot;. Pour créer un converter avancé, il faut créer une class qui hérite de <code>commands.Converter</code> et qui implémente la méthode <code>convert</code>. Cette méthode prends en paramètre le contexte de la commande et un argument de type quelconque ou précis. </p>
<p>Voici un exemple de converter avancé :</p>
<pre><code class="language-python">from discord.ext import commands

class MemberConverter(commands.Converter):
    async def convert(self, ctx : commands.Context, argument : str) -&gt; str:
        member = ctx.guild.get_member_named(argument)
        if member is None:
            raise commands.BadArgument(f&quot;Le membre {argument} n'existe pas.&quot;)
        return f&quot;Le membre {member} a été banni.&quot;
</code></pre>
<p>Ce converter prends en paramètre un nom de membre et renvoie un message de la forme &quot;Le membre {membre} a été banni&quot;. Si le membre n'existe pas, le converter renvoie une erreur.</p>
<hr />
<h1 id="exercices-14"><a class="header" href="#exercices-14">Exercices</a></h1>
<h3 id="exercice-1-14"><a class="header" href="#exercice-1-14">Exercice 1</a></h3>
<p>Créer une class qui hérite de <code>commands.Converter</code>, qui prends en paramètre une chaîne de caractère qui forme un temps comme par exemple &quot;10s&quot; ou &quot;1h&quot; et qui renvoie un objet <code>datetime.timedelta</code> qui représente le temps actuel + le temps passé en paramètre. Si la chaîne de caractère ne forme pas un temps valide, le converter doit renvoyer une erreur.</p>
<p>La structure de la class est la suivante :</p>
<pre><code class="language-python">from datetime import timedelta

class TimeConverter(commands.Converter):
    async def convert(self, ctx : commands.Context, argument : str) -&gt; datetime.timedelta:
        ...
</code></pre>
<p>Un exemple d'utilisation du converter est le suivant :</p>
<pre><code class="language-python">@bot.command()
async def time(ctx : commands.Context, argument : TimeConverter) -&gt; None:
    await ctx.send(argument)
</code></pre>
<p>Si on appel la commande <code>time</code> avec la chaîne de caractère &quot;10s&quot;, le bot renvoie la date et l'heure actuelle + 10 secondes.</p>
<details>
  <summary>Solution</summary>
<!-- Vraiment pas sur de la solution -->
<pre><code class="language-python">from datetime import timedelta

class TimeConverter(commands.Converter):
    async def convert(self, ctx : commands.Context, argument : str) -&gt; datetime.timedelta:
        time_dict = {&quot;s&quot;: 1, &quot;m&quot;: 60, &quot;h&quot;: 3600, &quot;d&quot;: 86400}
        unit = argument[-1]
        if unit not in time_dict:
            raise commands.BadArgument(f&quot;unit '{unit}' is invalid&quot;)
        try:
            time = int(argument[:-1])
        except ValueError:
            raise commands.BadArgument(f&quot;time '{argument[:-1]}' is not an integer&quot;)
        return discord.utils.utcnow() + timedelta(seconds=time * time_dict[unit])
</code></pre>
</details>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
